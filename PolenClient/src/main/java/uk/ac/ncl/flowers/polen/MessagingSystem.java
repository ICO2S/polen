package uk.ac.ncl.flowers.polen;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

import uk.ac.ncl.flowers.polen.util.HttpHandler;
import uk.ac.ncl.flowers.polen.util.MessageSerializer;

/**
 * Service to publish and receive POLEN messages.
 * 
 * <p>
 * Each MessagingSystem instance represents an individual remote messaging system. Messages can be published to that
 * system using the {@link #publish(Message)}. Messages generated by the remote system can be polled for using
 * the {@link #poll(String, Date, int)} method.
 * </p>
 * 
 * <p>
 * A MessagingSystem instance should be thread-safe. Any number of threads should be able to use it to send and receive
 * messages in parallel.
 * </p>
 * 
 * @author Goksel Misirli
 * @author Matthew Pocock
 */
public interface MessagingSystem {
	
	/**
	 * Publish a message.
	 * 
	 * <p>
	 * This will publish the message described by {@code message} to the remote messaging system. This call will block
	 * until the message has either been successfully published, or a failure has occurred.
	 * </p>
	 * 
	 * @param message			the message to publish
	 * @throws MessagingException	if the message could not be published either because of a fault in the client library or
	 * 							from the remote messaging system
	 */
	public void publish(Message message)
			throws MessagingException;

	
	/**
	 * Poll for messages.
	 * 
	 * <p>
	 * This will poll for messages by their {@code topic}, published after {@code date}, and limited to {@code limit} results.
	 * This call will block until the poll request either returns successfully, or a failure has occurred.  
	 * </p>
	 * 
	 * @param topic				topic of the messages to poll for
	 * @param date				date to return the messages published on or after 			
	 * @param limit				maximum number of messages to retrieve
	 * @return					list of messages matching the given criteria, empty if there are none
	 * @throws MessagingException	if the messages could not be polled either because of a fault in the client library or
	 * 							from the remote messaging system
	 */
	public List<Message> poll(String topic, Date date, int limit)
			throws MessagingException;

	
	/**
	 * Messaging system for Microbase.
	 * 
	 * <p>
	 * The Microbase class is initialised using the URI for the remote messaging service, for example http://synbio.ncl.ac.uk:8083/notification
	 * </p>
	 * 
	 * <p>
	 * This is the default implementation of the POLEN Messaging System, implemented with <a href="xxx">Microbase</a>.
	 * </p>
	 * 
	 * @author Goksel Misirli
	 * @author Matthew Pocock
	 */
	public static final class Microbase implements MessagingSystem {
		private final static Logger LOGGER=Logger.getLogger(Microbase.class.getName());
		private final String serviceUri;
		
		/**
		 * Create a new Microbase messaging system that will contact {@code serviceUri} for polling and publishing methods.
		 * 
		 * @param serviceUri
		 */
		public Microbase(String serviceUri)
		{
			this.serviceUri=serviceUri;
		}
		
		
		@Override
		public void publish(Message message)
				throws MessagingException
		{
			String postUri=String.format("%s/publish/", serviceUri);
			try
			{
				
				MessageSerializer serializer=new MessageSerializer();
				HashMap<String,String> parameters=new HashMap<String, String>();	 
				parameters.put("topic", message.getTopic());		 
				parameters.put("publisher", message.getPublisher());	
				String contentJson=serializer.messagePropertiesToJson(message);
				parameters.put("content", contentJson);		 

				String output=HttpHandler.post(postUri,parameters);	
				LOGGER.log(Level.INFO, "Received: " + output);				
			}
			catch (Exception exception)
			{
				String errorMessage=String.format("Could not publish the message to %s." , postUri);
				throw new MessagingException(errorMessage,exception);
			}
		}
		
		
		@Override
		public List<Message> poll(String topic, Date date,int limit)
				throws MessagingException
		{			
			String data=null;
			String timeStamp=null;
			try
			{	
				timeStamp=String.valueOf(date.getTime());
				String pollUri= String.format("%s/messagesByTopic/%s/%s/%s", serviceUri,topic,timeStamp,String.valueOf(limit));				
				data=HttpHandler.get(pollUri);
			}
			catch(Exception exception)
			{
				String message=String.format("Could not receive messages from %s using messageType: %s date: %s limit %d timestamp %s.", serviceUri, topic, date.toString(), limit, timeStamp);
				throw new MessagingException(message,exception);
			}
			
			try
			{
				JSONParser parser = new JSONParser();
				JSONObject jsonObject=(JSONObject)parser.parse(data);
				JSONArray jsonArray=(JSONArray) jsonObject.get("messages");
				ArrayList<Message> events=new ArrayList<Message>();
				if (jsonArray.size()>0)
				{
					for (int i=0;i<jsonArray.size(); i++)
					{
						Message message=new Message();
						JSONObject jsonMessage=(JSONObject)jsonArray.get(i);
						JSONObject content=(JSONObject)jsonMessage.get("content");
						String publisher = (String) jsonMessage.get("publisher");
						message.setTopic(topic);
						message.setPublisher(publisher);
						
						Set<Map.Entry<String,String>> entries= (Set<Map.Entry<String,String>>)content.entrySet();
						for (Map.Entry<String, String> entry : entries)
						{
							String key=entry.getKey();
							if ("name".equals(key))
							{
								message.setName(entry.getValue());
							}
							else if ("description".equals(key))
							{
								message.setDescription(entry.getValue());
							}
							else if ("uri".equals(key))
							{
								message.setResourceUri(entry.getValue());
							}
							else
							{							
								message.addProperty(key, entry.getValue());
							}
						}
												
						events.add(message);				
					}
				}
				return events;
			}
			catch(Exception exception)
			{
				String message=String.format("Could not parse messages from %s using messageType: %s date: %s limit %d.", serviceUri, topic, date.toString(), limit);
				throw new MessagingException(message,exception);
			}

		}				
		
	}
}
